use std::fs::File;
use std::io::Read;
use std::collections::{HashMap,VecDeque};
use serde::{Deserialize, Serialize};
use std::cell::RefCell;
use ndarray::Array2;
use ndarray_npy::{ReadNpyError, ReadNpyExt, WriteNpyExt};
use std::env;
use std::io::BufWriter;
use std::time::Instant;

#[derive(Serialize, Deserialize, Debug)]
struct Cell {
    row: u32,
    col: u32,
    accum: f64,
    elev:f64,
    neighbors:Vec<Vec<u32>>,
    parents:Vec<Vec<u32>>,

    #[serde(default)]
    is_explored:bool,
}

pub fn id_hash(row:u32,col:u32,rows:u32,cols:u32) -> u32 {
    return row*rows + col%cols;
}

pub fn same_node(node_a:Cell, node_b:Cell) -> bool {
    if (node_a.row == node_b.row) && (node_a.col == node_b.col) {
        return true
    }
    return false;
}

fn search_drainage(start:Cell,threshold:f64) ->Vec<Vec<Cell>> {
    if start.accum >= threshold {
        return Vec::new();
    }

    let mut explored = 
}



fn main() {
    let file = File::open("./accumulations/cells.json").expect("Failed to open file");

    let start = Instant::now();
    let mut data: HashMap<u32,Cell> = serde_json::from_reader(file).expect("Failed to deserialize JSON file.");
    let elapsed = start.elapsed();
    println!("JSON data successfuly serialized. Calculating HAND values ...");
    println!("Elapsed time: {:.2?}",elapsed);

    let rows: u32 = 1047;
    let cols: u32 = 1613;



    

    let drainage_threshold:f64 = 1000.0;
    let mut hand: Array2<f64> = Array2::from_elem((rows as usize,cols as usize),0.0);
    
    let start = Instant::now();
    let mut num_solved: u128 = 0;
    let mut explored_ids:Vec<u32> = Vec::new();
    for row in 0..rows{
        for col in 0..cols {

            if num_solved % 10000 == 0 {
                let progress = (num_solved *100)/((rows as u128)*(cols as u128));
                println!("HAND Calculation Progress {:.2}%",progress);
            }

            //reset explored status
            while let Some(explored_id) = explored_ids.pop() {
                if let Some(explored_cell) = data.get_mut(&explored_id) {
                    explored_cell.is_explored = false;
                }
            }

            //initialize stack
            let cell_id = id_hash(row,col,rows,cols);
            let cell: &mut Cell = data.get_mut(&cell_id).unwrap();
            let mut stack: VecDeque<u32> = VecDeque::new();
            stack.push_back(cell_id);
            cell.is_explored = true;
            let cell_elev  = cell.elev;

            let mut drainage_found = false;
            let mut path_lengths:Vec<f64> = Vec::new();

            while (stack.len() > 0) && !drainage_found {
                
                //do dfs pop
                let node_id  = stack.pop_back().unwrap();
                //let node: &Cell = data.get(&node_id).unwrap();
                
                let node = data.get(&node_id).unwrap();
                let neighbor_locs = node.neighbors.clone();

                for (i,neighbor_loc) in neighbor_locs.iter().enumerate() {
                    let neighbor_row = neighbor_loc[0];
                    let neighbor_col = neighbor_loc[1];
                    let neighbor_id = id_hash(neighbor_row,neighbor_col,rows,cols);
                    
                    if let Some(neighbor) = data.get_mut(&neighbor_id) {
                        if !neighbor.is_explored {
                            
                            if neighbor.accum  >= drainage_threshold {

                                //add current neighbor id and remaining neighbors as candidates for drainage
                                for (j,candidate_loc) in neighbor_locs.iter().enumerate() {
                                    if j >=i {
                                        let candidate_row = candidate_loc[0];
                                        let candidate_col = candidate_loc[1];
                                        let candidate_id = id_hash(candidate_row,candidate_col,rows,cols);
                                        candidate_nearest_drainage.push(candidate_id)
                                    }
                                }
                                drainage_found = true;
                                break;


                                /*
                                let hand_value = cell_elev - neighbor.elev;
                                hand[[row as usize,col as usize]] = hand_value;
                                drainage_found = true;
                                break;*/


                            }

                            stack.push_back(neighbor_id);
                            neighbor.is_explored = true;
                            explored_ids.push(neighbor_id);
                        }
                    }

                }
            }
            num_solved += 1;
        }
    }
    let elapsed = start.elapsed();
    println!("Hand Values Calculated.");
    println!("Elapsed time: {:.2?}",elapsed);

    let writer = BufWriter::new(File::create("./accumulations/hand.npy").unwrap());
    match hand.write_npy(writer){
        Ok(_) => {println!("{} was written.","./accumulations/hand.npy")},
        Err(err) => {println!("An error occured while writing {}. See below:\n{}","./accumulations/hand.npy",err)},
    };

}
